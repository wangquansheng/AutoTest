from AppiumLibrary import AppiumLibrary
from appium.webdriver.common.touch_action import TouchAction
import datetime
import time
import re, os


class AppiumGientechLibrary(AppiumLibrary):

    def __init__(self, timeout=5, run_on_failure='Capture Page Screenshot'):
        self.__super = super(AppiumGientechLibrary, self)
        self.__super.__init__(timeout, run_on_failure)

    def set_appium_implicit_wait(self, value):
        """appium的隐式等待

        The value can be given as a number that is considered to be
        seconds or as a human-readable string like ``1 second``.
        The previous value is returned and can be used to restore
        the original value later if needed.

        This keyword sets the implicit wait for all opened browsers.
        Use `Set Browser Implicit Wait` to set it only to the current
        browser.

        """
        driver = self._current_application()
        driver.implicitly_wait(value)
        self._implicitly_wait = value

    def keyboard_input(self, locator, value):
        """
        键盘输入

        :param value:
        :return:
        """
        element = self._element_find(locator, True, True)
        element.click()
        self.execute_adb_shell(f"input text {value}")
        self._info(f"Keyboard input '{value}'.")

    def slide_down_element(self, locator):
        """
        向下移动到某元素
        :param locator:
        :return:
        """
        driver = self._current_application()
        wait = self._implicitly_wait
        before_swipe = driver.page_source
        width = self.get_window_width()
        height = self.get_window_height()
        while True:
            try:
                self.__should_be_visible(locator)
                self.set_appium_implicit_wait(wait)
                self._info(f"Slide down element '{locator}'.")
                break
            except Exception as e:
                self.set_appium_implicit_wait(1)
                driver.swipe(width // 2, height // 4 * 3, width // 2, height // 4, 1000)
                after_swipe = driver.page_source
                if before_swipe == after_swipe:
                    raise Exception(e)
                else:
                    before_swipe = after_swipe

    def slide_up_element(self, locator):
        """
        向上移动到某元素
        :param locator:
        :return:
        """
        driver = self._current_application()
        wait = self._implicitly_wait
        before_swipe = driver.page_source
        width = self.get_window_width()
        height = self.get_window_height()
        while True:
            try:
                self.__should_be_visible(locator)
                self.set_appium_implicit_wait(wait)
                self._info(f"Slide up element '{locator}'.")
                break
            except Exception as e:
                self.set_appium_implicit_wait(1)
                driver.swipe(width // 2, height // 4, width // 2, height // 4 * 3, 1000)
                after_swipe = driver.page_source
                if before_swipe == after_swipe:
                    raise Exception(e)
                else:
                    before_swipe = after_swipe

    def swipe_down_half_screen(self, times=1, intervals=0):
        """
        向下滑动半屏
        :param times: 次数
        :param intervals: 间隔时间
        :return:
        """
        if times < 1:
            times = 1
        driver = self._current_application()
        before_swipe = driver.page_source
        width = self.get_window_width()
        height = self.get_window_height()
        for i in range(times):
            driver.swipe(width // 2, height // 4 * 3, width // 2, height // 4, 1000)
            if intervals:
                time.sleep(intervals)
            after_swipe = driver.page_source
            if before_swipe == after_swipe:
                self._info(f"Swipe down half screen '{times}'.")
                return
            else:
                before_swipe = after_swipe
        self._info(f"Swipe down half screen '{times}'.")

    def swipe_up_half_screen(self, times=1, intervals=0):
        """
        向上滑动半屏
        :param times: 次数
        :param intervals: 间隔时间
        :return:
        """
        if times < 1:
            times = 1
        driver = self._current_application()
        before_swipe = driver.page_source
        width = self.get_window_width()
        height = self.get_window_height()
        for i in range(times):
            driver.swipe(width // 2, height // 4, width // 2, height // 4 * 3, 1000)
            if intervals:
                time.sleep(intervals)
            after_swipe = driver.page_source
            if before_swipe == after_swipe:
                self._info(f"Swipe up half screen '{times}'.")
                return
            else:
                before_swipe = after_swipe
        self._info(f"Swipe up half screen '{times}'.")

    def close_app(self):
        """关闭appium实例"""
        try:
            self.quit_application()
        except:
            pass
        try:
            self._debug('Closing all applications')
            self._cache.close_all()
        except:
            pass

    def send_key(self, locator, value):
        """
        输入数据
        :param locator:
        :param value:
        :return:
        """
        if self._get_platform() == "ios":
            self.input_value(locator, value)
            return
        a = self.execute_adb_shell("ime list -s")
        input_method = "com.android.adbkeyboard/.AdbIME"
        if input_method not in a:
            yosemite_path = os.path.dirname(os.path.abspath(__file__)) + r"\ADBKeyboard.apk"
            driver = self._current_application()
            driver.install_app(yosemite_path)
            time.sleep(5)
        a = self.execute_adb_shell("settings get secure default_input_method")
        if input_method not in a:
            self.execute_adb_shell(f"settings put secure default_input_method {input_method}")
        element = self._element_find(locator, True, True)
        element.click()
        self.execute_adb_shell(f"am broadcast -a ADB_INPUT_TEXT --es msg '{value}'")
        self._info("Setting text '%s' into text field '%s'" % (value, locator))

    def get_verification_code(self, overtime_time=60):
        """
        获取短信验证码
        :param overtime_time: 超时时间（秒）
        :return:
        """
        driver = self._current_application()
        locator = '//*[contains(@text,"验证码")]'
        wait = self._implicitly_wait

        def get_code():
            driver.open_notifications()
            self.set_appium_implicit_wait(1)
            try:
                elements = driver.find_elements_by_xpath(locator)
                for element in elements:
                    data = element.get_attribute("text")
                    da = re.findall("([\d]+)", data)
                    if da and len(da) == 1 and len(da[-1]) < 7:
                        coordinate = element.location
                        x, y = coordinate["x"], coordinate["y"]
                        driver.swipe(x, y, 1, y, 100)
                        return da[-1]
                return ""
            except Exception as e:
                return ""
            finally:
                self.set_appium_implicit_wait(wait)
                self.go_back()

        start_time = datetime.datetime.now()
        overtime_time = datetime.timedelta(seconds=overtime_time)
        while True:
            verification_code = get_code()
            end_tiem = datetime.datetime.now()
            if verification_code:
                self._info(f"Verification code '{verification_code}'")
                return verification_code
            elif end_tiem - start_time > overtime_time:
                self._info(f"Verification code :\"\"")
                return ""
            else:
                time.sleep(4)

    def capture_page_screenshot(self, filename=None):
        """Takes a screenshot of the current page and embeds it into the log.

        `filename` argument specifies the name of the file to write the
        screenshot into. If no `filename` is given, the screenshot is saved into file
        `appium-screenshot-<counter>.png` under the directory where
        the Robot Framework log file is written into. The `filename` is
        also considered relative to the same directory, if it is not
        given in absolute format.

        `css` can be used to modify how the screenshot is taken. By default
        the bakground color is changed to avoid possible problems with
        background leaking when the page layout is somehow broken.
        """
        try:
            return self.__super.capture_page_screenshot(filename)
        except:
            pass

    def Drag_drop(self, locator, offset_x, offset_y):
        element = self._element_find(locator, True, True)
        action = TouchAction(driver)
        action.long_press(dragElement).move_to(offset_x, offset_y).release().perform();
        self._info(f"Drag drop '{locator, offset_x, offset_y}'")

    def __should_be_visible(self, locator):
        if not self._element_find(locator, True, True).is_displayed():
            raise AssertionError("Element '%s' should be visible "
                                 "but did not" % locator)
